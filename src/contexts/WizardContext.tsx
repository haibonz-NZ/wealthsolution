import React, { createContext, useContext, useState, useEffect } from "react";

export type IdentityRegion = "CN" | "HK" | "US" | "UK" | "CA" | "AU" | "SG" | "JP" | "EU" | "OTHER";

export type RoleType = "self" | "spouse" | "child" | "parent" | "grandchild";

export interface IdentityNode {
  id: string; // Unique ID for drag item
  role: RoleType;
  region: IdentityRegion;
  // Risk tags generated by assessment
  risks: string[]; // e.g. "US_TAX_PERSON", "CFC_CONTROLLED_FOREIGN_CORP"
}

export interface WizardData {
  // Upgraded from simple string[] to complex object array
  identities: IdentityNode[]; 
  
  // Legacy fields kept for compatibility or simplified flow
  residence: IdentityRegion[];
  
  assets: {
    domestic: number; // 0: <1000w, 1: 1000-5000w, 2: >5000w
    foreign: number;
    types: string[]; // 'real_estate', 'equity', 'cash', 'insurance', 'trust'
  };
  painPoints: string[]; // 'tax', 'heirs', 'divorce', 'frozen', 'debt'
}

interface WizardContextType {
  data: WizardData;
  updateData: (partial: Partial<WizardData>) => void;
  addIdentity: (identity: IdentityNode) => void;
  removeIdentity: (id: string) => void;
  updateIdentityRisks: (id: string, risks: string[]) => void;
  resetData: () => void;
}

const defaultData: WizardData = {
  identities: [], // Empty initially, user drags to populate
  residence: ["CN"],
  assets: {
    domestic: 1,
    foreign: 0,
    types: []
  },
  painPoints: []
};

const WizardContext = createContext<WizardContextType | undefined>(undefined);

export function WizardProvider({ children }: { children: React.ReactNode }) {
  const [data, setData] = useState<WizardData>(() => {
    try {
      const saved = localStorage.getItem("gwrc_wizard_data");
      if (saved) {
        const parsed = JSON.parse(saved);
        
        // Extreme Defensive Validation
        // 1. Check identities array
        if (!Array.isArray(parsed.identities)) {
            console.warn("Invalid identities format (not array), resetting.");
            localStorage.removeItem("gwrc_wizard_data");
            return defaultData;
        }

        // 2. Check for legacy string items in identities
        const hasLegacyString = parsed.identities.some((item: any) => typeof item === 'string');
        if (hasLegacyString) {
            console.warn("Legacy data detected (string identities), resetting wizard context.");
            localStorage.removeItem("gwrc_wizard_data");
            return defaultData;
        }

        // 3. Ensure deep object structure for assets
        if (!parsed.assets || typeof parsed.assets !== 'object') {
             console.warn("Invalid assets format, resetting.");
             localStorage.removeItem("gwrc_wizard_data");
             return defaultData;
        }

        // 4. Ensure painPoints is array
        if (!Array.isArray(parsed.painPoints)) {
             console.warn("Invalid painPoints format, resetting.");
             localStorage.removeItem("gwrc_wizard_data");
             return defaultData;
        }
        
        // Merge with default to ensure missing fields are filled
        return { 
            ...defaultData, 
            ...parsed,
            // Ensure deep merge for assets if needed, though shallow merge of root keys + defensive checks above should suffice for now.
            // But let's be safe for assets object specifically:
            assets: { ...defaultData.assets, ...parsed.assets } 
        };
      }
    } catch (e) {
      console.error("Failed to parse wizard data", e);
      // Corrupt JSON -> Clear it
      localStorage.removeItem("gwrc_wizard_data");
    }
    return defaultData;
  });

  useEffect(() => {
    localStorage.setItem("gwrc_wizard_data", JSON.stringify(data));
  }, [data]);

  const updateData = (partial: Partial<WizardData>) => {
    setData(prev => ({ ...prev, ...partial }));
  };

  const addIdentity = (identity: IdentityNode) => {
    setData(prev => ({
      ...prev,
      identities: [...prev.identities, identity]
    }));
  };

  const removeIdentity = (id: string) => {
    setData(prev => ({
      ...prev,
      identities: prev.identities.filter(i => i.id !== id)
    }));
  };

  const updateIdentityRisks = (id: string, risks: string[]) => {
    setData(prev => ({
      ...prev,
      identities: prev.identities.map(i => 
        i.id === id ? { ...i, risks } : i
      )
    }));
  };

  const resetData = () => {
    setData(defaultData);
    localStorage.removeItem("gwrc_wizard_data");
  };

  return (
    <WizardContext.Provider value={{ data, updateData, addIdentity, removeIdentity, updateIdentityRisks, resetData }}>
      {children}
    </WizardContext.Provider>
  );
}

export function useWizard() {
  const context = useContext(WizardContext);
  if (!context) {
    throw new Error("useWizard must be used within a WizardProvider");
  }
  return context;
}
